<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Basic Probability</title>
    <link rel="stylesheet" href="tufte.min.css"/>
    <style>
      .katex { font-size: 0.95em !important; }
      foreignObject { font-size: 2em; }
    </style>
    <!-- local D3 -->
    <script type="text/javascript" src="d3.min.js" charset="utf-8"></script>
    <!-- fetch D3 -->
    <!-- <script src="https://d3js.org/d3.v5.min.js"></script> -->

    <!-- local KaTeX -->
    <link defer rel="stylesheet" href="katex.min.css">
    <script defer src="katex.min.js" charset="uft-8"></script>
    <script defer src="auto-render.min.js" charset="utf-8" onload="renderMathInElement(document.body);"></script>
    <!-- fetch KaTeX-->
    <!--   <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous"> -->
    <!-- <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script> -->
    <!-- <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script> -->

    <!-- local jStat -->
    <script type="text/javascript" src="jstat.min.js"></script>
    <!-- fetch jStat -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js"></script> -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <article>
      <h1 id="page">Basic Probability</h1>
      <p class="subtitle">Edward A. Roualdes</p>
      <section>
        <h2 id="contents">Contents</h2>
        <bold><a href="#introduction">Introduction</a></bold></br>
        <bold><a href="#finite">Probability Over Finite Sets</a></bold></br>
        <bold><a href="#axioms">Axioms of Probability</a></bold></br>
        <bold><a href="#independentevents">Independent Events</a></bold></br>
        <bold><a href="#conditionalprobability">Conditional Probability</a></bold></br>
        <bold><a href="#bayestheorem">Bayes' Theorem</a></bold></br>
        <bold><a href="#lawtotalprobability">Law of Total Probability</a></bold></br>
      </section>

      <section>
        <h2 id="introduction">Introduction</h2>
        <p>
          Probability is a seemingly simple and yet deceptively
          complicated subject.  Though much of it can be concealed and
          this is the route we'll take here.
        </p>

        <p>
          These notes first introduce some notation of probability,
          alongside a core set of beliefs that most people tend to
          agree on.<span class="marginnote">This is not to say that
          most people agree on the definition of probability.  See for
          example Dr. Martha K. Smith's short essay
          title <a href="https://web.ma.utexas.edu/users/mks/statmistakes/probability.html">"What
          is Probability?".</a></span> With this notation in hand, we
          state same basic rules of working with probabilities.  Note
          that these two sections are inherently different than the
          last section Estimating Probabilities.  In Axioms of
          Probabilities and Rules of Probabilities, we claim knowledge
          of the probabilities of interest.  This is not always the
          case in the real world, and thus one must also attend to
          making educated guesses about probabilities that we claim
          exist.  In the last section Estimating Probabilities, we
          discuss how to estimate unknown probabilities.
        </p>

      </section>

      <section>
        <h2 id="finite">Probability Over Finite Sets</h2>

        <p>
          Before we get to a more theoretical treatment of
          probability, let's introduce the notation of probability.
          Syntactically, probability works like a function.  We'll use
          the bold, capital letter p, \( \mathbb{P} \).
        </p>

        <p>
          A probability function \( \mathbb{P} \) acts on sets, called
          events in statistics, instead of numbers like you're
          probably used to.  Hence, probability is a set
          function.<span class="marginnote">Here's a refresher
          on <a href="lecturenotes/sets.html">sets and set theory</a>,
          in case you want it.</span> A function \( \mathbb{P} \)
          acts on sets and returns a real number guaranteed to be in
          the set \( [0, 1]
          \).<span class="marginnote">Mathematically, we'd write \(
          \mathbb{P}: S \rightarrow [0, 1] \)</span>
        </p>

        <p>
          Notice that we have yet to specify how a function \(
          \mathbb{P} \) maps sets to real numbers between \( 0 \) and
          \(1 \).  So far, we've just said that it does this.  In
          fact, the way a function \( \mathbb{P} \) maps sets to real
          numbers between \( 0 \) and \( 1 \) can be quite complex.
          Specifying more complex examples of \( \mathbb{P} \)  will be
          discussed in greater detail under the topic of probability
          distributions.  For now, let's consider a case of \(
          \mathbb{P} \) specified on finite sets.
        </p>

        <p>
          Consider the set \( S = \{1, 2, 3, 4, 5, 6\} \) and \( A =
          \{2, 4, 6 \} \) a susbet of \( S \).  We seek to define a
          set function that produces the probability \( 1/2 \) when
          applied to \( A \), \( \mathbb{P}[A] = 1/2 \).  We'd also
          like this same set function to be more general, such that it
          produces similarly intuitive results for other subsets of \(
          S \).
        </p>

        <p>
          Luckily, since \( S \) is finite, a relatively simple
          solution works here.  Put \( \mathbb{P} \) to be the set
          function that maps arbitrary sets \( B \subset S \) to the fraction

          \[ \mathbb{P}[B] = \frac{|B|}{|S|}. \]

          Recall from the notes on <a href="sets.html">Basic Set
          Theory</a> that the cardinality \( | \cdot | \) of a finite
          set counts the elements.  Thus, if we applied this set
          function to \( A \subset S \), we'd get \( \mathbb{P}[A] =
          3/6 = 1/2 \), as desired.  With this more general definition
          of \( \mathbb{P} \) applied to finite sets, we will hence
          forward refer to it as a probability
          distribution.<span class="marginnote">Such functions \(
          \mathbb{P} \) are referred to as probability distributions
          because they distribute probability across subsets of the
          set \( S \) on which they act.</span>
        </p>

        <p>
          The probability distribution above also yields other
          intuitive results.  For instance, \( \mathbb{P}[\{1\}] = 1/6
          \).  Or more generally, \( \mathbb{P}[\{s\}] = 1/6 \) for
          any single element \(s \in S \).  This is the same logic
          that yields equal probabilities and thus fairness in a coin,
          a die, or a standard deck of cards.
        </p>

        <p>
          There are other ways one could distribute probability across
          a set \( S \) than what is defined above.  The specific
          choice above yields intuitive results, but is not otherwise
          special.  You could, for instance, define your own
          probability distribution that assigns unequal weights to the
          two sides of a coin.
        </p>

        <p>
          We'll defer discussion about more complex versions of \(
          \mathbb{P} \) until the notes Probability Distributions.
          Below, we describe some general properties of arbitrary
          probability distributions.  The three axioms of probability
          are what separate general set functions from probability
          distributions.  As an exercise throughout the next section,
          verify that our probability distribution defined above meets
          all the axioms of probability.
        </p>

      </section>

      <section>
        <h2 id="axioms">Axioms of Probability</h2>
        <p>
          Despite lacking one definition that satisfies all
          statisticians, there are a few well established statements
          about probability.  These are often called
          the <a href="https://en.wikipedia.org/wiki/Probability_axioms">axioms
          of probability</a>.
        </p>

        <p>
          Let \( S \) be the set of all possible outcomes of interest,
          often called the sample space.  Let \( A, A_1, A_2, \ldots,
          \) be subsets of \( S \).  The first axiom of
          probability<label for="axiom1" class="margin-toggle
          sidenote-number"></label><input type="checkbox" id="axiom1"
          class="margin-toggle"/><span class="sidenote">\(
          \mathbb{P}[A] \geq 0 \) for any set \( A \subseteq S
          \).</span> states that the probability of any set, say \( A
          \) must be greater than or equal to \( 0 \).  The second
          axiom of probability<label for="axiom2" class="margin-toggle
          sidenote-number"></label><input type="checkbox" id="axiom2"
          class="margin-toggle"/><span class="sidenote">\(
          \mathbb{P}[S] = 1 \).</span> states that the probability of
          all possible events of interest is equal to \( 1 \).  The
          third axiom of probability<label for="axiom3"
          class="margin-toggle
          sidenote-number"></label><input type="checkbox" id="axiom3"
          class="margin-toggle"/><span class="sidenote">\(
          \mathbb{P}[\cup_{n = 1}^{\infty} A_n] = \sum_{n =
          1}^{\infty} \mathbb{P}[A_n] \) if \( A_1, A_2, \ldots \) are
          a <a href="https://en.wikipedia.org/wiki/Countable_set">countable</a>
          sequence of pairwise disjoint sets.</span> state the
          probabilty of disjoint sets is equal to the sum of the
          probabilities of the sets.
        </p>

        <p>
          The first and second axioms of probability insist that
          probabilities must be bounded between \( 0 \) and \( 1 \).
          Let \( A \) be the blue set below.  As first drawn, it has
          probability \( \mathbb{P}[{\color{#00BFFF} A}] = \) <span id="PA"></span>, but
          feel free to change it.
        </p>

        <div id="A1and2"></div>

        <p>
          The third axiom of probability will be better understood
          with a simple example.  Consider the sample space of a fair
          die.  Let \( S = \{1, 2, 3, 4, 5, 6 \} \) and let \( A_n =
          \{ n \} \) for \(n = 2, 3, 4 \).  Notice that
          \({\color{#FF6DAE}\cup_{n = 2}^4 A_n = \{ 2, 3, 4 \}} \).
          We expect the probability of rolling a \( 2 \), a \( 3 \),
          or a \( 4 \) to be \( 1/2 \) for a fair die.  This is
          exactly what the third axiom of probability is telling us,
          that you can sum together probabilities across disjoint
          sets. Visually we can think of this as one half of the
          sample space split into three equally sized disjoint sets,
          counted as one event.
        </p>
          <div id="A3"></div>

        <p>
          Mathematically, it would look like this.

          \[
          \begin{aligned}
          \mathbb{P}[ \{ 2, 3, 4 \} ] & = \mathbb{P}\left[\bigcup_{n = 2}^4 A_n \right] \\
          & = \sum_{n=2}^4 \mathbb{P}[A_n] \\
          & = \mathbb{P}[\{ 2 \}] + \mathbb{P}[\{ 3 \}] + \mathbb{P}[\{ 4 \}] \\
          & = \frac{1}{6} + \frac{1}{6} + \frac{1}{6} \\
          & = \frac{1}{2} \\
          \end{aligned}
          \]
        </p>
      </section>

      <section>
        <h2 id="independentevents">Independent Events</h2>
        <p>
          TODO Assume A is an event guaranteed to happen and it just
          happened at the same time that B happened.  Then we want \(
          \mathbb{P}[A \cap B] \) to be equal to \( \mathbb{P}[B] \).
          The only way we can get this, is to multiple \(
          \mathbb{P}[A] = 1 \) by \( \mathbb{P}[B]. \)
        </p>
        <p>
          Let \( A, B \subseteq S \).  Events \( A \) and \( B \) are
          said to be independent events if

          \[ \mathbb{P}[A \cap B] = \mathbb{P}[A]\mathbb{P}[B]. \]

          Let \( A \) be the event that a randomly selected card from
          a standard deck is a Queen.  Let \( B \) be the event that a
          randomly selected card from a standard deck is a heart.
          Note that only one card is being drawn from one standard
          deck of cards.  Convince yourself that \( \mathbb{P}[A] =
          1/4 \) and \( \mathbb{P}[B] = 1/13 \).  Further, \(
          \mathbb{P}[A \cap B] = 1/52 \), since there there is only
          one Queen of hearts.  Because

          \[ \frac{1}{52} = \mathbb{P}[A \cap B] = \mathbb{P}[A]
          \mathbb{P}[B] = \frac{1}{4}\frac{1}{13} \]

          the events \( A \) and \( B \) are independent.
        </p>

        <p>
          Note that in the example above, both sides of the equation
          are calculated first and then compared.  If the equation
          holds with equality, the events in question are said to be
          independent.  If the equation does not hold, the events are
          said to be depenedent.
        </p>

        <p>
          Further, independence is in general different than the
          probability associated with disjoint sets.  For two nonempty
          events to be independent, they need to have some nonempty
          intersection.
        </p>
      </section>

      <section>
        <h2 id="conditionalprobability">Conditional Probability</h2>

        <p>
          Let \( A, B \subseteq S \) such that \( \mathbb{P}[B] > 0 \).
          The probability of the event \(A \) given that the event \( B
          \) has already taken place is

          \[ \mathbb{P}[A | B] = \frac{\mathbb{P}[A \cap
          B]}{\mathbb{P}[B]}\]

          and is known as conditional probability.  The display below
          allows you to drag the two events (circles) to increase or
          decrease the intersection.
        </p>

        <div id="condprobability"></div>

        <p>
          Notice that conditional probability has the intersection of
          the events \( A \) and \( B \) in the numerator.  When \(
          \mathbb{P}[A \cap B] = 0 \), then \( \mathbb{P}[A | B] = 0
          \) also.  When the two events do overlap, conditional
          probability scales the probability of the intersection
          relative to \( \mathbb{P}[B] \) instead of relative to \(
          \mathbb{P}[S] = 1 \).
        </p>

        <div id="condprobabilitystuff"></div>

        <p>
          What conditions on \( B \) are necessary for \( \mathbb{P}[A
          \cap B] = \mathbb{P}[A | B] \)?
        </p>
      </section>

      <section>
        <h2 id="bayestheorem">Bayes' Theorem</h2>

        <p>
          Let \( A, B \) be any events with positive probability.
          Bayes' theorem states

          \[ \mathbb{P}[A | B] = \frac{\mathbb{P}[B | A]
          \mathbb{P}[A]}{ \mathbb{P}[B]}. \]
        </p>

        <p>
          TODO (ear) example
        </p>
      </section>


      <section>
        <h2 id="lawtotalprobability">Law of Total Probability</h2>
        <p>
          Let \( B_1, B_2, \ldots, B_k \) be an exhaustive and
          disjoint collection of subsets of \( S \), where \(
          \mathbb{P}[B_k] > 0 \) for all \( k \).  For any set \( A
          \), the law of total probability states

          \[ \mathbb{P}[A] = \sum_{k = 1}^K \mathbb{P}[A | B_k]
          \mathbb{P}[B_k]. \]
        </p>

        <p>
          It is perhaps easiest to understand the law of total
          probability in a picture and by noticing that the summand,
          via conditional probability, ammounts to \( \mathbb{P}[A |
          B_k] \mathbb{P}[B_k] = \mathbb{P}[A \cap B_k] \).  Then \(
          \mathbb{P}[{\color{#D4CA3A} A}] \) can be found by summing
          the probability of disjoint sets, each one of which is the
          intersection of \( A \) with one of the \( B_k \)s.
        </p>

        <div id="totalprobability"></div>

        <p>
          Suppose there are 3 urns, each containing 2 balls.  Urn 1
          contains 2 white balls, urn 2 contains 1 white ball and 1
          red ball, and urn 3 contains 2 red balls.  Let \( A = \{
          \text{ a red abll is chosen } \} \) and \( B_k = \{ \text{
          urn } k \text{ is chosen } \} \) for \( k = 1, 2, 3 \).
          Then \( \mathbb{P}[B_k] = 1/3, \mathbb{P}[A | B_1] = 0,
          \mathbb{P}[A | B_2] = 1/2, \text{ and } \mathbb{P}[A|B_3] = 1 \),
          such that

          \[ \mathbb{P}[A] = 0 \frac{1}{3} + \frac{1}{2} \frac{1}{3} +
          1 \frac{1}{3} = \frac{1}{2}. \ \]
        </p>

      </section>

      <hr>
      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International</a>
    </article>

    <script type="text/javascript">

      let svgWidth = 400;
      let svgHeight = svgWidth / 1.618;

      let margin = { top: 40, right: 20, bottom: 40, left: 60 },
          width = svgWidth - margin.left - margin.right,
          height = svgHeight - margin.top - margin.bottom;

      let support = height * width;

      function area(C) {
          return Math.PI * C.r * C.r;
      }

      function probability(C) {
          return Math.round(100 * area(C) / support) / 100;
      }

      function intersection(A, B) {
          let d = Math.hypot(B.x - A.x, B.y - A.y);

          if (d === 0) {
              return area(A);
          }
          if (d < A.r + B.r) {

              let a = A.r * A.r,
                  b = B.r * B.r;

              let x = (a - b + d * d) / (2 * d),
                  z = x * x,
                  y = Math.sqrt(a - z);

              if (d < Math.abs(B.r - A.r)) {
                  return Math.PI * min(a, b)
              }
              let A1 = a * Math.asin(y / A.r),
                  B1 = b * Math.asin(y / B.r),
                  C1 = y * (x + Math.sqrt(z + b - a));

              return  A1 + B1 - C1;
          }
          return 0;
      }

      function A1and2() {
          let svg = d3.select("#A1and2")
              .append("svg")
              .attr("width",  svgWidth)
              .attr("height", svgHeight)
              .append("g")
              .attr("transform", `translate( ${margin.left - 25}, ${margin.top} )`);


          svg.append("rect")
              .attr("x", 0)
              .attr("y", 0)
              .attr("height", height)
              .attr("width", width)
              .attr("stroke", "black")
              .attr("rx", 15)
              .attr("ry", 15)
              .attr("fill", "none")
              .attr("fill-opacity", "0");

          svg.append("foreignObject")
              .attr("x", width - 5)
              .attr("y", height - 20)
              .attr("width", 40)
              .attr("height",40)
              .append("xhtml:text")
              .text("\\( S \\)");

          let circles = [{r: 50, id: "A", x: width / 2, y: height / 2}];

          let drag = d3.drag()
              .on("start", dragstarted)
              .on("drag", dragged)
              .on("end", dragended);

          let events = svg.selectAll("events")
              .data(circles)
              .join("g")
              .attr("class", "circle")
              .attr("transform", d => `translate( ${width/2}, ${height/2})`)
              .call(drag);

          events.append("circle")
              .attr("class", "circle")
              .attr("r", d => d.r)
              .attr("fill", "#00BFFF");

          events.append("foreignObject")
              .attr("x", d => -15)
              .attr("y", d => -20)
              .attr("width", 40)
              .attr("height", 40)
              .append('xhtml:text')
              .text(d => `\\( ${d.id} \\)`);

          function dragstarted(d) {
              d3.select(this).raise().attr("stroke", "black");
          }

          function dragged(d) {
              d.x += d3.event.dx;
              d.y += d3.event.dy;
              let r = +d3.select("circle.circle").attr("r");
              [d.x, d.y] = checkBounds(d, r);

              d3.select(this)
                  .attr("transform", `translate( ${d.x}, ${d.y} )`);
          }

          function checkBounds(d, r) {
              if (d.x - r < 0) {
                  d.x = r;
              }
              if (d.x + r > width) {
                  d.x = width - r;
              }
              if (d.y - r < 0) {
                  d.y = r;
              }
              if (d.y + r > height) {
                  d.y = height - r;
              }
              return [d.x, d.y];
          }

          function dragended(d) {
              d3.select(this).attr("stroke", null);
          }

          d3.selectAll("#PA")
              .attr("style", "border-bottom: 1px dotted #000;")
              .text(probability(circles[0]))
              .call(d3.drag()
                    .on("drag", adjustp));

          function adjustp() {
              circles[0].r += d3.event.dx / 5;
              if (2 * circles[0].r > height) {
                  circles[0].r = height / 2;
              }
              if (circles[0].r < 0) {
                  circles[0].r = 0;
              }
              let transform = d3.select("g.circle").attr("transform");
              let [cx, cy] = transform.split(",");
              d = {x: +cx.slice(10), y: +cy.slice(0, -1)};
              [d.x, d.y] = checkBounds(d, circles[0].r);

              let p = probability(circles[0]);
              p = p < 0 ? 0 : p;
              p = p > 1 ? 1 : p;

              d3.selectAll("#PA")
                  .text(p);

              d3.select("g.circle")
                  .attr("transform", `translate( ${d.x}, ${d.y} )`);

              d3.select("circle.circle")
                  .attr("r", circles[0].r);
          }
      }
      A1and2();

      function A3() {
          let svg = d3.select("#A3")
              .append("svg")
              .attr("width",  svgWidth)
              .attr("height", svgHeight)
              .append("g")
              .attr("transform", `translate( ${margin.left - 25}, ${margin.top} )`);


          let xScale = d3.scaleLinear()
              .domain([0, 1])
              .range([0, width]);

          svg.append("rect")
              .attr("x", 0)
              .attr("y", 0)
              .attr("height", height)
              .attr("width", width)
              .attr("stroke", "black")
              .attr("rx", 15)
              .attr("ry", 15)
              .attr("fill", "none")
              .attr("fill-opacity", "0");

          svg.append("foreignObject")
              .attr("x", width - 5)
              .attr("y", height - 20)
              .attr("width", 40)
              .attr("height",40)
              .append("xhtml:text")
              .text("\\( S \\)");

          svg.append("rect")
              .attr("x", xScale(1 / 6))
              .attr("y", 0)
              .attr("height", height)
              .attr("width", xScale(1/6))
              .attr("fill", "#FF6DAE")
              .attr("stroke", "black");

          svg.append("foreignObject")
              .attr("x", xScale(1/6) + 10)
              .attr("y", height / 2)
              .attr("width", 40)
              .attr("height", 40)
              .append("xhtml:text")
              .text("\\( A_2 \\)");

          svg.append("rect")
              .attr("x", xScale(1 / 3))
              .attr("y", 0)
              .attr("height", height)
              .attr("width", xScale(1/6))
              .attr("fill", "#FF6DAE")
              .attr("stroke", "black");

          svg.append("foreignObject")
              .attr("x", xScale(1/3) + 10)
              .attr("y", height / 2)
              .attr("width", 40)
              .attr("height", 40)
              .append("xhtml:text")
              .text("\\( A_3 \\)");

          svg.append("rect")
              .attr("x", xScale(1 / 2))
              .attr("y", 0)
              .attr("height", height)
              .attr("width", xScale(1/6))
              .attr("fill", "#FF6DAE")
              .attr("stroke", "black");

          svg.append("foreignObject")
              .attr("x", xScale(1/2) + 10)
              .attr("y", height / 2)
              .attr("width", 40)
              .attr("height", 40)
              .append("xhtml:text")
              .text("\\( A_4 \\)");
      }
      A3();

            function condProbability() {
          let radius = 51;

          let svg = d3.select("#condprobability")
              .append("svg")
              .attr("width",  svgWidth)
              .attr("height", svgHeight)
              .append("g")
              .attr("transform", `translate( ${margin.left - 25}, ${margin.top} )`);


          svg.append("rect")
              .attr("x", 0)
              .attr("y", 0)
              .attr("height", height)
              .attr("width", width)
              .attr("stroke", "black")
              .attr("rx", 15)
              .attr("ry", 15)
              .attr("fill", "none")
              .attr("fill-opacity", "0");

          const circles = [{x: width/4, y: height/2, label: "A",
                            color: "#00BFFF", r: radius},
                           {x: width/4 + 1.25*radius, y: height/2, label: "B",
                            color: "#FF6DAE", r: radius}];

          let drag = d3.drag()
              .on("start", dragstarted)
              .on("drag", dragged)
              .on("end", dragended);

          let node = svg.selectAll(".node")
              .data(circles)
              .join("g")
              .attr("class", "circle")
              .attr("transform", d => `translate( ${d.x}, ${height/2} )`)
              .call(drag);

          node.append("circle")
              .attr("class", "circle")
              .attr("r", d => d.r)
              .attr("fill", d => d.color)
              .attr("fill-opacity", 0.75);

          svg.append("foreignObject")
              .attr("x", width - 5)
              .attr("y", height - 20)
              .attr("width", 40)
              .attr("height",40)
              .append("xhtml:text")
              .text("\\( S \\)");


          node.append("foreignObject")
              .attr("x", d => -15)
              .attr("y", d => -20)
              .attr("width", 40)
              .attr("height", 40)
              .append('xhtml:text')
              .text(d => `\\( ${d.label} \\)`);

          function dragstarted(d) {
              d3.select(this)
                  .raise()
                  .attr("stroke", "black");
          }

          function dragged(d) {
              d.x += d3.event.dx;
              if (d.x - radius < 0) {
                  d.x = radius;
              }
              if (d.x + radius > width) {
                  d.x = width - radius;
              }
              d3.select(this)
                  .attr("transform", `translate( ${d.x}, ${height/2} )`);

              if (d.label === "A") {
                  updateDisplay(d, circles[1]);
              } else {
                  updateDisplay(circles[0], d);
              }
          }

          function dragended(d) {
              d3.select(this)
                  .attr("stroke", null);
          }

          var disp = d3.select("#condprobabilitystuff")
              .append("div")
              .attr("width",  width  + margin.left + margin.right)
              .attr("height", height + margin.top  + margin.bottom)
              .append("g")
              .attr("transform", `translate( ${margin.left}, ${margin.top})`)
              .append("div")
              .attr("class", "container");

          let row = disp.append("div")
              .attr("class", "probabilities");

          var intersectionAB = "\\( \\mathbb{P}[A \\cap B] \\)",
              conditionalAB = "\\( \\mathbb{P}[A | B] = \\frac{\\mathbb{P}[A \\cap B]}{\\mathbb{P}[B]} \\)";

          row.append("div")
              .append("p")
              .attr("id", "intersection")
              .text(intersectionAB);

          row.append("div")
              .append("p")
              .attr("id", "conditional")
              .text(conditionalAB);

          var support = svgWidth * svgHeight,
              areaB = area(circles[1]);

          updateDisplay(circles[0], circles[1]);

          function updateDisplay(A, B){
              disp.selectAll("#intersectionValue").remove();
              disp.selectAll("#conditionalValue").remove();

              let AintB = intersection(A, B);
              let AandB = AintB / support,
                  AcondB = AintB / areaB;

              disp.selectAll("#intersection")
                  .append("text")
                  .attr("id", "intersectionValue")
                  .text(" = " + Math.round(AandB * 100) / 100);

              disp.selectAll("#conditional")
                  .append("text")
                  .attr("id", "conditionalValue")
                  .text(" = " + Math.round(AcondB * 100) / 100);
          }
      }

      condProbability();

      function totalProbability() {

          let svg = d3.select("#totalprobability")
              .append("svg")
              .attr("width",  svgWidth)
              .attr("height", svgHeight)
              .append("g")
              .attr("transform", `translate( ${margin.left - 25}, ${margin.top} )`);

          let xScale = d3.scaleLinear()
              .domain([0, 1])
              .range([0, width]);

          svg.append("rect")
              .attr("x", 0)
              .attr("y", 0)
              .attr("height", height)
              .attr("width", width)
              .attr("stroke", "black")
              .attr("rx", 15)
              .attr("ry", 15)
              .attr("fill", "none")
              .attr("fill-opacity", "0");

          svg.append("foreignObject")
              .attr("x", width - 5)
              .attr("y", height - 20)
              .attr("width", 40)
              .attr("height",40)
              .append("xhtml:text")
              .text("\\( S \\)");

          svg.append("ellipse")
              .attr("rx", 100)
              .attr("ry", 40)
              .attr("cx", width / 2)
              .attr("cy", height / 2 - 40)
              .attr("stroke", "black")
              .attr("fill", "#D4CA3A");

          svg.append("foreignObject")
              .attr("x", xScale(1/6) - 40)
              .attr("y", height / 2)
              .attr("width", 40)
              .attr("height", 40)
              .append("xhtml:text")
              .text("\\( B_1 \\)");

          svg.append("rect")
              .attr("x", xScale(1 / 6))
              .attr("y", 0)
              .attr("height", height)
              .attr("width", xScale(1/6))
              .attr("fill", "none")
              .attr("stroke", "black");

          svg.append("foreignObject")
              .attr("x", xScale(1/6) + 10)
              .attr("y", height / 2)
              .attr("width", 40)
              .attr("height", 40)
              .append("xhtml:text")
              .text("\\( B_2 \\)");

          svg.append("circle")
              .attr("cx", xScale(1/6) + 30)
              .attr("cy", height / 2 - 40)
              .attr("r", 20)
              .attr("stroke", "none")
              .attr("fill", "#D4CA3A")
              .on("mouseover", overB2capA)
              .on("mouseout", outB2capA);

          let B2capA = svg.append("foreignObject")
              .attr("class", "B2capA")
              .attr("x", xScale(0))
              .attr("y", height / 2 - 120)
              .attr("width", 100)
              .attr("height", 50)
              .append("xhtml:text")
              .text("\\( A \\cap B_2 \\)");

          svg.append("rect")
              .attr("class", "B2capAcover")
              .attr("x", xScale(0))
              .attr("y", -51)
              .attr("height", 50)
              .attr("width", 100)
              .attr("stroke-width", 0)
              .attr("fill", "#fffff8");

          function overB2capA(d, i) {
              d3.select(".B2capAcover")
                  .attr("fill", "none");
          }

          function outB2capA(d, i) {
              d3.select(".B2capAcover")
                  .attr("fill", "#fffff8");
          }

          svg.append("rect")
              .attr("x", xScale(1 / 3))
              .attr("y", 0)
              .attr("height", height)
              .attr("width", xScale(1/6))
              .attr("fill", "none")
              .attr("stroke", "black");

          svg.append("foreignObject")
              .attr("x", xScale(1/3) + 10)
              .attr("y", height / 2)
              .attr("width", 40)
              .attr("height", 40)
              .append("xhtml:text")
              .text("\\( B_3 \\)");

          svg.append("rect")
              .attr("x", xScale(1/3))
              .attr("y", height / 2 - 73)
              .attr("width", xScale(1/6))
              .attr("height", 65)
              .attr("stroke", "none")
              .attr("stroke-width", 0)
              .attr("fill", "#D4CA3A")
              .on("mouseover", overB3capA)
              .on("mouseout", outB3capA);

          let B3capA = svg.append("foreignObject")
              .attr("class", "B3capA")
              .attr("x", xScale(1 / 3) - 20)
              .attr("y", height / 2 - 120)
              .attr("width", 150)
              .attr("height", 50)
              .append("xhtml:text")
              .text("\\( A \\cap B_3 \\)");

          svg.append("rect")
              .attr("class", "B3capAcover")
              .attr("x", xScale(1 / 3) - 20)
              .attr("y", -51)
              .attr("height", 50)
              .attr("width", 100)
              .attr("stroke-width", 0)
              .attr("fill", "#fffff8");

          function overB3capA(d, i) {
              d3.select(".B3capAcover")
                  .attr("fill", "none");
          }

          function outB3capA(d) {
              d3.select(".B3capAcover")
                  .attr("fill", "#fffff8");
          }

          svg.append("rect")
              .attr("x", xScale(1 / 2))
              .attr("y", 0)
              .attr("height", height)
              .attr("width", xScale(1/6))
              .attr("fill", "none")
              .attr("stroke", "black");

          svg.append("foreignObject")
              .attr("x", xScale(1/2) + 10)
              .attr("y", height / 2)
              .attr("width", 40)
              .attr("height", 40)
              .append("xhtml:text")
              .text("\\( B_4 \\)");

          svg.append("rect")
              .attr("x", xScale(1/2))
              .attr("y", height / 2 - 73)
              .attr("width", xScale(1/6))
              .attr("height", 65)
              .attr("stroke", "none")
              .attr("stroke-width", 0)
              .attr("fill", "#D4CA3A")
              .on("mouseover", overB4capA)
              .on("mouseout", outB4capA);

          let B4capA = svg.append("foreignObject")
              .attr("class", "B4capA")
              .attr("x", xScale(1 / 2) + 15)
              .attr("y", height / 2 - 120)
              .attr("width", 100)
              .attr("height", 50)
              .append("xhtml:text")
              .text("\\( A \\cap B_4 \\)");

          svg.append("rect")
              .attr("class", "B4capAcover")
              .attr("x", xScale(1 / 2) + 15)
              .attr("y", -51)
              .attr("height", 50)
              .attr("width", 100)
              .attr("stroke-width", 0)
              .attr("fill", "#fffff8");

          function overB4capA(d, i) {
              d3.select(".B4capAcover")
                  .attr("fill", "none");
          }

          function outB4capA(d) {
              d3.select(".B4capAcover")
                  .attr("fill", "#fffff8");
          }

          svg.append("rect")
              .attr("x", xScale(2 / 3))
              .attr("y", 0)
              .attr("height", height)
              .attr("width", xScale(1/6))
              .attr("fill", "none")
              .attr("stroke", "black");

          svg.append("foreignObject")
              .attr("x", xScale(2/3) + 10)
              .attr("y", height / 2)
              .attr("width", 40)
              .attr("height", 40)
              .append("xhtml:text")
              .text("\\( B_5 \\)");

          svg.append("circle")
              .attr("cx", xScale(2/3) + 25)
              .attr("cy", height / 2 - 40)
              .attr("r", 20)
              .attr("stroke", "none")
              .attr("fill", "#D4CA3A")
              .on("mouseover", overB5capA)
              .on("mouseout", outB5capA);

          let B5capA = svg.append("foreignObject")
              .attr("class", "B5capA")
              .attr("x", xScale(5 / 6))
              .attr("y", height / 2 - 120)
              .attr("width", 100)
              .attr("height", 50)
              .append("xhtml:text")
              .text("\\( A \\cap B_5 \\)");

          svg.append("rect")
              .attr("class", "B5capAcover")
              .attr("x", xScale(5 / 6))
              .attr("y", -51)
              .attr("height", 50)
              .attr("width", 100)
              .attr("stroke-width", 0)
              .attr("fill", "#fffff8");

          function overB5capA(d, i) {
              d3.select(".B5capAcover")
                  .attr("fill", "none");
          }

          function outB5capA(d) {
              d3.select(".B5capAcover")
                  .attr("fill", "#fffff8");
          }

          svg.append("foreignObject")
              .attr("x", xScale(2/3) + 60)
              .attr("y", height / 2)
              .attr("width", 40)
              .attr("height", 40)
              .append("xhtml:text")
              .text("\\( B_6 \\)");

          svg.append("foreignObject")
              .attr("x", xScale(1/3))
              .attr("y", height / 2 - 35)
              .attr("width", 30)
              .attr("height", 30)
              .append("xhtml:text")
              .text("\\( A \\)");
      }
      totalProbability();
    </script>
  </body>
</html>
